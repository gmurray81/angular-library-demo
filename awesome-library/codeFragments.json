{"codeFragments":[{"label":"loading style","content":"  .loading {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    background-color: gray;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n  }"},{"label":"img style","content":"  img {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n  }"},{"label":"fadein animation","content":"  .fadein {\n    animation-duration: 2s;\n    animation-name: fadein;\n  }\n  @keyframes fadein {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }"},{"label":"cubicEase","content":"function cubicEaseInOut(t: number) {\r\n    if (t < .5) {\r\n        t *= 2.0;\r\n        let v = (t * t * t) / 2.0;\r\n        return v;\r\n    } else {\r\n        t = ((1.0 - t) * 2.0);\r\n        let v = ((1.0 - (t * t * t)) / 2.0) + .5;\r\n        return v;\r\n    }\r\n}"},{"label":"clipRegion","content":"export class ClipRegion {\r\n    \r\n    currRad: number;\r\n\r\n    updateRadius(elapsed: number): boolean {\r\n        let done = false;\r\n        let p = (elapsed - this.delay) / this.duration;\r\n        \r\n        if (p > 1.0) {\r\n            p = 1.0;\r\n            done = true;\r\n        }\r\n        if (p < 0) {\r\n            return;\r\n        }\r\n\r\n        p = cubicEaseInOut(p);\r\n        \r\n        this.currRad = this.rad * p;\r\n        return done;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.moveTo(this.x + this.rad, this.y);\r\n        ctx.ellipse(this.x, this.y, \r\n            this.currRad, this.currRad,\r\n             0, 0, 360);\r\n    }\r\n\r\n    constructor(\r\n        public x: number, \r\n        public y: number, \r\n        public rad: number, \r\n        public duration: number, \r\n        public delay: number) {\r\n            \r\n        }\r\n}"},{"label":"clipRegions","content":"export class ClipRegions {\r\n    private _regions: ClipRegion[] = [];\r\n\r\n    addRegion(x: number, y: number, rad: number, \r\n        duration: number, delay: number) {\r\n        this._regions.push(new ClipRegion(\r\n            x, y, rad, duration, delay\r\n        ));\r\n    }\r\n\r\n    update(elapsed: number) {\r\n        let done = true;\r\n        this._regions.map((r) => {\r\n            if (!r.updateRadius(elapsed)) {\r\n                done = false;\r\n            }\r\n        });\r\n        return done;\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        this._regions.map((r) => {\r\n            r.draw(ctx);\r\n        })\r\n    }\r\n}"},{"label":"scene","content":"export class Scene {\r\n\r\n    private _context: CanvasRenderingContext2D;\r\n\r\n    constructor(private _canvas: HTMLCanvasElement,\r\n    private _clientWidth: number,\r\n    private _clientHeight: number,\r\n    private _devicePixelRatio: number,\r\n    private _requestFrame: (act: () => void) => void,\r\n    private _clipRegions: ClipRegions,\r\n    private _img: HTMLImageElement\r\n    ) {\r\n        this._context = this._canvas.getContext(\"2d\");\r\n        this._canvas.width = this._clientWidth * this._devicePixelRatio;\r\n        this._canvas.height = this._clientHeight * this._devicePixelRatio;\r\n        \r\n    }\r\n\r\n    private _startTime: number;\r\n\r\n    startTicking(): void {\r\n        this._startTime = new Date().getTime();\r\n        this._requestFrame(() => this.tick());\r\n    }\r\n\r\n    tick(): void {\r\n        let currTime = new Date().getTime();\r\n        let elapsed = currTime - this._startTime;\r\n\r\n        let done = this._clipRegions.update(elapsed);\r\n\r\n        this._context.save();\r\n        this._context.scale(this._devicePixelRatio, this._devicePixelRatio);\r\n        this._context.clearRect(0,0,this._clientWidth, this._clientHeight);\r\n\r\n        this._context.beginPath();\r\n\r\n        this._clipRegions.draw(this._context);\r\n\r\n        this._context.closePath();\r\n        this._context.clip(\"nonzero\");\r\n\r\n        this._context.drawImage(this._img,\r\n        0,0, this._clientWidth, this._clientHeight);\r\n\r\n        this._context.restore();\r\n\r\n        if (!done) {\r\n            this._requestFrame(() => this.tick());\r\n        }\r\n    }\r\n}"},{"label":"buildClipRegions","content":"  buildClipRegions(width: number, height: number, duration: number) {\n    this._clipRegions = new ClipRegions();\n    let rad = width / 15;\n    let maxDelay = duration * .25;\n    let minDuration = duration * .5;\n    for (var i = 0; i < width; i += width / 15) {\n      for (var j = 0; j < height; j += width / 15) {\n        let currDelay = Math.random() * maxDelay;\n        let currDuration = minDuration + ((duration - minDuration) - currDelay) * Math.random();\n        this._clipRegions.addRegion(\n          i, j, rad, currDuration, currDelay\n        );\n      }\n    }\n  }"},{"label":"initializeScene","content":"    this._scene = new Scene(\n      this.canvas.nativeElement,\n      this.canvas.nativeElement.clientWidth,\n      this.canvas.nativeElement.clientHeight,\n      window.devicePixelRatio,\n      (act) => this._ngZone.runOutsideAngular(() => {\n        window.requestAnimationFrame(act); \n      }), \n      this._clipRegions,\n      this.img.nativeElement);\n    \n    this._scene.startTicking();"},{"label":"drawStar","content":"drawStar(ctx: CanvasRenderingContext2D, x: number,\r\n       y: number, radius: number, outerExtent: number, innerExtent: number): any {\r\n    ctx.beginPath();\r\n\r\n    let out = true;\r\n    let first = true;\r\n    for (let i = 0; i <= 2 * Math.PI; i += Math.PI / 5.0) {\r\n      let currAngle = i - Math.PI / 2.0;\r\n      let currX = 0;\r\n      let currY = 0;\r\n\r\n      let r = radius * innerExtent;\r\n      if (out) {\r\n        r = radius * outerExtent;\r\n      }\r\n      out = !out;\r\n\r\n      currX = x + r * Math.cos(currAngle);\r\n      currY = y + r * Math.sin(currAngle);\r\n\r\n      if (first) {\r\n        first = false;\r\n        //console.log(\"M\" + x + \",\" + y);\r\n        ctx.moveTo(currX, currY);\r\n      } else {\r\n        //console.log(\"L\" + x + \",\" + y);\r\n        ctx.lineTo(currX, currY);\r\n      }\r\n    }\r\n\r\n    ctx.closePath();\r\n  }"}]}